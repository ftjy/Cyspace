import { Command } from '@author.io/node-shell'
import build from '../lib/build.js'
import path from 'path'
import {
  container,
  abort,
  env,
  port,
  launch
} from '../lib/utility.js'
import flag from '../lib/flags.js'
import chalk from 'chalk'
import glob from 'glob'

const TestCommand = new Command({
  name: 'test',
  description: 'Test code in a specific runtime.',
  flags: {
    runtime: {
      alias: 'rt',
      description: 'The runtime to execute tests in.',
      options: [/node(@.*)?/i, /browser(@.*)?/i, /deno(@.*)?/i, 'manual'],
      default: 'node'
    },
    browser: {
      alias: 'b',
      description: 'Specify the browser to test with (default is chromium). If this option is specified, the runtime is automatically set to "browser".',
      options: ['chrome', 'firefox']
    },
    ignorecircular: flag.ignorecircular,
    port: {
      alias: 'p',
      description: 'The port where the manual web server can be accessed.',
      default: 9000,
      type: 'number'
    },
    dropconsole: {
      alias: 'dc',
      description: 'Drop console.log and other console operations during minification. Console operations are kept by default during only.',
      type: 'boolean'
    },
    nobuild: {
      alias: 'b',
      description: 'Prevent building the library before running the test.',
      type: 'boolean'
    },
    force: {
      alias: 'f',
      description: 'Force a build process to run before testing.',
      type: 'boolean'
    },
    http_server: {
      alias: 'http',
      description: 'Specify a relative filepath as the source of a HTTP test server.',
      type: 'string'
    },
    http_server_port: {
      alias: 'tp',
      description: 'Expose the test server outside the container on a specific port.',
      default: 12345
    },
    replace: flag.replace,
    external: flag.external,
    buildoption: flag.buildoption,
    autoimport: {
      alias: 'i',
      description: 'Auto-import a module dependency (manual testing only). Only supports ES Modules. Specify the full import, such as "import MyValue from \'@scope/module\'" (or the absolute/relative URL)',
      type: 'string',
      allowMultipleValues: true
    },
    cover: {
      alias: 'c',
      description: 'Generate code coverage reports',
      type: 'boolean'
    },
    coverageDirectory: {
      alias: 'cd',
      description: 'The directory where coverage reports will be saved.',
      type: 'string',
      default: '.coverage'
    },
    cleanCoverage: {
      alias: 'cc',
      description: 'Remove any existing code coverage reports before creating new ones.',
      type: 'boolean'
    }
  },
  async handler (meta) {
    const { image, version, runtime, command } = await container(meta, '/app', 'base').catch(abort)
    const ignored = meta.flag('ignorecircular')

    if (ignored.length > 0) {
      env(command, `IGNORE_CIRCULAR_DEPENDENCY=${ignored.join(',')}`)
    }

    if (!meta.flag('dropconsole')) {
      env(command, 'KEEP_CONSOLE=true')
    }

    if (meta.flag('browser') !== null) {
      env(command, `PUPPETEER_PRODUCT=${browser}`)
    }

    if (runtime === 'manual') {
      port(command, `${meta.flag('port')}:9000`)
      env(command, `TEST_PORT=${meta.flag('port')}`)

      if (meta.flag('autoimport').length > 0) {
        env(command, `AUTOIMPORT_MODULES=${meta.flag('autoimport').join(',').replace(/("|')/i, '\$1')}`)
      }
    }

    if (meta.flag('cover')) {
      env(command, `COVERAGE_DIR=${meta.flag('coverageDirectory')}`)

      if (meta.flag('cleanCoverage')) {
        env(command, 'CLEAN_COVERAGE=true')
      }
    }

    if (meta.flag('http_server')) {
      env(command, `HTTP_TEST_SERVER=${path.join('/app', meta.flag('http_server'))}`)
      env(command, `HTTP_TEST_SERVER_PORT=${meta.flag('http_server_port')}`)
      port(command, `${meta.flag('http_server_port')}:80`)
    }

    if (meta.flag('buildoption')) {
      const RE = /(?<key>[^=:]+)(:|=)(?<value>[^=:]+)/i
      const cfg = {}
      for (const keypair of meta.flag('buildoption')) {
        const { key, value } = RE.exec(keypair).groups
        cfg[key] = isNaN(value) ? (value.toLocaleLowerCase() === 'false' ? false : (value.toLocaleLowerCase() === 'true' ? true : value)) : (value.indexOf('.') >= 0 ? parseFloat(value) : parseInt(value, 10))
      }
      if (Object.keys(cfg).length > 0) {
        env(command, `ROLLUP_CFG=${JSON.stringify(cfg).replace(/("|')/g, '\\$1')}`)
      }
    }

    command.push(
      `${image}:${version} ${image === 'node' ? 'base' : ''}node -r source-map-support/register /utility/test/run-${runtime}.js`,
      meta.flags.unrecognized.join(' ')
    )

    // The build utility auto-builds.
    // No need to run it twice.
    if (meta.flag('runtime') !== 'manual') {
      meta.flags.recognized.mode = meta.flag('mode')
      build(meta)
    }

    launch(command, meta.flag('verbose'))
  },
  commands: [{
    name: 'coverage',
    description: 'Consolidate coverage reports into a single report.',
    flags: {
      runtime: {
        alias: 'rt',
        description: 'The runtime to execute tests in.',
        default: 'base'
      }
    },
    async handler (meta) {
      const files = glob.sync(path.join(path.resolve('.coverage'), '.nyc_output', '**/*.json'))

      if (files.length === 0) {
        console.log('\n' + chalk.red('No coverage reports available.') + '\n' + chalk.dim.italic('Try running unit tests first.'))
        process.exit(0)
      }

      const { image, version, runtime, command } = await container(meta, '/app', 'base').catch(abort)

      command.push(`${image}:${version} node /utility/test/coverage.js`, meta.flags.unrecognized.join(' '))

      launch(command, meta.flag('verbose'))
    }
  }]
})

export { TestCommand as default }
