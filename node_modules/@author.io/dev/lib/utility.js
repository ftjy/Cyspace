import path from 'path'
import readline from 'readline'
import http from 'https'
import fs from 'fs'
import os from 'os'
import chalk from 'chalk'
import { latest } from './docker.js'
import { fileURLToPath } from 'url'
import { spawn, spawnSync } from 'child_process'
const __dirname = path.dirname(fileURLToPath(import.meta.url)) // eslint-disable-line

function volumes (cmd) {
  const args = new Set(...Array.from(arguments).slice(1))

  if (args.size > 0) {
    args.forEach(keypair => {
      if (os.platform() === 'win32') {
        keypair = keypair.replace(/^([A-Za-z]+):/i, '').replace(/\\/g, '/').split(/:|=/)
      } else {
        keypair = keypair.split(/:|=/)
      }

      const source = path.resolve(keypair[0])
      const dest = keypair[1]

      try {
        cmd.push(`-v "${fs.realpathSync(source)}:${dest}"`)
      } catch (e) {
        console.log(`"${source}" is not accessible or could not be found.`)
        console.log(e.message)
      }
    })
  }

  return cmd
}

function env (cmd) {
  const args = new Set(Array.from(arguments).slice(1).flat())

  args.forEach(val => {
    if (val && val.trim().length > 3 && val.indexOf('=') > 0) {
      cmd.push(`-e "${val}"`)
    }
  })

  return cmd
}

function port (cmd) {
  const args = new Set(Array.from(arguments).slice(1).flat())

  args.forEach(val => cmd.push(`-p ${val}`))

  return cmd
}

function prettyCommand (cmd) {
  cmd = Array.isArray(cmd) ? cmd.join(' ') : cmd
  const match = /[\s\n]+(?<image>(?:[^\s]+)\/(?:[^\s]+)):(?<version>(?:\d+\.?){3})\s+(?<command>.*)$/g.exec(cmd)

  if (match) {
    cmd = cmd.replace(match[0], ' \\\n')
  }

  cmd = cmd.split(/\s+-/g).join(' \\\n  -').replace(/(?!=\s)([^\s\d]+:[\d\.]+[^\s]+)(?!=\s[\w])/i, '\\\n  $1 \\\n   ')
  cmd = cmd.replace(/-{1,2}v(?:olume)?\s+"(.*):(.*)"/gi, `${chalk.magenta('-v')} "${chalk.magenta.dim('$1')}${chalk.dim(':')}${chalk.magentaBright('$2')}"`)
  cmd = cmd.replace(/-{1,2}e(?:nv)?\s+"(.*)=(.*)"/gi, `${chalk.blue('-e')} "${chalk.blueBright.bold('$1')}${chalk.dim('=')}${chalk.dim.blue.italic('$2')}"`)
  cmd = cmd.replace(/-{1,2}p(?:ort)?\s+(\d+)(:)?(\d+)/gi, `${chalk.cyan('-p')} ${chalk.italic.bold.cyanBright('$1')}${chalk.dim('$2')}${chalk.cyan('$3')}`)
  cmd = cmd.replace(/(-{1,2}w(?:orkdir)?)\s+([^\\]*)/gi, `${chalk.yellow('$1 ' + chalk.bold('$2'))}`)
  cmd = cmd.replace(/\\\n/gi, chalk.dim('\\') + '\n')
  cmd = cmd.replace(/["|']/gi, chalk.dim('"'))
  cmd = cmd.replace(/^(docker|podman)/i, chalk.italic('$1'))
  cmd = cmd.replace(/(--cap-add)=([^\s\n]+)/gi, `${chalk.yellow('$1')}${chalk.dim('=')}${chalk.yellow.bold('$2')}`)
  cmd = cmd.replace(/(--?(rm|it|remove))/gi, chalk.dim('$1'))

  if (match) {
    const { image, version, command } = match.groups
    cmd = cmd + '  ' + chalk.green.dim(image) + chalk.dim(':') + chalk.green.dim.italic(version) + ' \\\n    ' + chalk.greenBright.italic(command)
  }

  return `\n${chalk.italic.bold.dim('Command:')}\n\n${cmd}\n`
}

async function container (meta, workdir = '/app', base = '') {
  const browser = meta.flag('browser')
  const baseruntime = meta.flag('runtime') || ''
  const runtime = browser ? 'browser' : baseruntime.split('@')[0].toLowerCase()
  let version = baseruntime.split('@').length < 2 ? null : baseruntime.split('@').pop()
  const image = meta.flag('image') + (runtime === 'manual' ? base : runtime)
  const command = [`${meta.flag('engine')} run --rm ${meta.flag('interactive') ? '-it' : '-t'} -w ${workdir}`]

  command.push('--cap-add=NET_ADMIN')
  command.push('--cap-add=NET_RAW')

  if (!version) {
    version = await latest(meta.flag('image'), runtime === 'manual' ? 'base' : runtime).catch(abort)
  }

  volumes(command, meta.flag('volume').concat([`${process.cwd()}:/app`]))

  env(command, meta.flag('env').concat([`REALPATH=${process.cwd()}`]))

  if (meta.flag('alias') && meta.flag('alias').length > 0) {
    const alias = Object.fromEntries(meta.flag('alias').map(i => i.split('=')))
    env(command, `IMPORT_PATH_ALIASES=${JSON.stringify(alias).replace(/\"/g, '\\"')}`)
  }

  if (meta.flag('peer')) {
    env(command, 'INSTALL_PEER_DEPENDENCIES=true')
  }

  if (meta.flag('embed') && meta.flag('embed').length > 0) {
    env(command, `EMBED_MODULES=${meta.flag('embed').join(',')}`)
  }

  if (meta.flag('replace') && meta.flag('replace').length > 0) {
    const data = {}
    meta.flag('replace').forEach(keypair => {
      keypair = keypair.split('=')
      const key = keypair.shift()
      const value = keypair.join('=')
      data[key] = value
    })

    if (Object.keys(data).length > 0) {
      env(command, `REPLACE=${JSON.stringify(data).replace(/\"/gi, '\\"')}`)
    }
  }

  return {
    runtime,
    version,
    image,
    command
  }
}

function launch (command, verbose = false, sync = false) {
  command = Array.isArray(command) ? command.join(' ') : command
  if (verbose) {
    console.log(prettyCommand(command) + '\n')
  }

  if (sync) {
    spawnSync(command, options)
  } else {
    spawn(command, options)
  }
}

function prompt (q, defaultValue = '') {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  })

  return new Promise(resolve => {
    rl.question(q + (defaultValue !== '' ? ` (${defaultValue})` : '') + ' ', answer => {
      if (answer.length === 0) {
        answer = defaultValue
      }

      rl.close()
      resolve(answer)
    })
  })
}

function abort (e) {
  console.error(e)
  process.exit(1)
}

function mkdirp (dir) {
  dir = path.resolve(dir)

  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true })
  }
}

function readJSON (p) {
  try {
    return JSON.parse(fs.readFileSync(p).toString())
  } catch (e) {
    console.error(e)
    return null
  }
}

function writeJSON (p, obj, compressed = false) {
  try {
    fs.writeFileSync(p, compressed ? JSON.stringify(obj) : JSON.stringify(obj, null, 2))
  } catch (e) {
    console.error(e)
  }
}

function GET (url, secure = true) {
  if (!secure) {
    process.env.NODE_TLS_REJECT_UNAUTHORIZED = 0
  }

  return new Promise((resolve, reject) => {
    http.get(url, res => {
      let body = ''
      res.on('data', c => { body += c })
      res.on('error', reject)
      res.on('end', () => {
        resolve({
          status: res.statusCode,
          body
        })
      })
    }).on('error', reject)
  })
}

function hr (count) {
  return (new Array(count)).join('-')
}

const REALPATH = `-e "REALPATH=${process.cwd()}"`
const CWD = `-v "${process.cwd()}:/app"`
const RUN = engine => `${engine} run -t --rm`
const options = { shell: true, stdio: [0, 1, 2] }

const all = {
  volumes,
  REALPATH,
  CWD,
  RUN,
  prompt,
  abort,
  mkdirp,
  options,
  readJSON,
  writeJSON,
  GET,
  hr,
  container,
  launch,
  port,
  env,
  prettyCommand
}

export {
  all as default,
  volumes,
  REALPATH,
  CWD,
  RUN,
  prompt,
  abort,
  mkdirp,
  options,
  readJSON,
  writeJSON,
  __dirname,
  GET,
  hr,
  container,
  launch,
  port,
  env,
  prettyCommand
}
