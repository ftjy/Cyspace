#!/usr/bin/env node
import { Shell } from '@author.io/node-shell'
import { fileURLToPath } from 'url'
import fs from 'fs'
import path from 'path'
// import { hr } from './lib/utility.js'
import chalk from 'chalk'
import BuildCommand from './commands/build.js'
import TestCommand from './commands/test.js'
import EnvironmentCommand from './commands/environment.js'
import WorkspaceCommand from './commands/workspace.js'
import ReportCommand from './commands/report.js'
import UpdateCommand from './commands/update.js'
import InitCommand from './commands/init.js'
import PsCommand from './commands/ps.js'

const package_json = path.join(process.cwd(), 'package.json')
const __dirname = path.dirname(fileURLToPath(import.meta.url)) // eslint-disable-line
const pkg = JSON.parse(fs.readFileSync(path.join(__dirname, 'package.json')))
const { name, version, description } = pkg
const commands = [
  BuildCommand,
  TestCommand,
  EnvironmentCommand,
  WorkspaceCommand,
  ReportCommand,
  UpdateCommand,
  InitCommand,
  PsCommand
]

const commonflags = {
  ignore: ['update', 'init'],
  engine: {
    description: 'The container engine to run.',
    default: 'docker',
    options: ['docker', 'podman']
  },
  image: {
    description: 'The image containing the build/test environment.',
    default: 'author/dev-',
    type: 'string'
  },
  verbose: {
    description: 'Add verbose logging. This usually displays the command used to launch the container.',
    type: 'boolean'
  },
  mode: {
    description: 'Specfiy which mode should be applied to the operation. Modes are specified in package.json files.',
    type: 'string'
  },
  volume: {
    alias: 'v',
    description: 'Add/override a volume in the runtime container. Ex: -v /path/to/source:/volume',
    type: 'string',
    allowMultipleValues: true
  },
  env: {
    alias: 'e',
    description: 'Add environment variables to the runtime container. Ex: -e "VAR:value"',
    type: 'string',
    allowMultipleValues: true
  },
  alias: {
    alias: 'a',
    description: 'Alias an import path.',
    type: 'string',
    allowMultipleValues: true
  },
  interactive: {
    alias: ['i', 'it'],
    description: 'Run interactively. By default, this is true. If an environment variable called "CI" exists, it defaults to false.',
    type: 'boolean',
    default: process.env.CI === undefined
  },
  peer: {
    description: 'Install peer dependencies (package.json) before executing a command.',
    type: 'boolean',
    default: false
  }
}

const cli = new Shell({
  name: 'dev',
  version,
  description,
  commonflags,
  commands
})

// If a library has a package.json file with a dev attribute, autoconfigure appropriate commands by setting flags.
if (fs.existsSync(package_json)) {
  const primitives = new Set(['string', 'number', 'boolean'])
  const data = JSON.parse(fs.readFileSync(package_json).toString())

  if (data.dev) {
    // Applied to all commands
    cli.use((meta, next) => {
      Object.keys(commonflags).forEach(flag => {
        if (data.dev[flag] && meta.input.indexOf(`--${flag}`) < 0) {
          meta.flags.recognized[flag] = data.dev[flag]
        }
      })

      next()
    })

    // Applied to specific commands
    cli.useExcept(['update', 'init'], (meta, next) => {
      const mode = meta.flag('mode') || data.dev.mode || 'default'

      if (mode !== 'default') {
        console.log(`${chalk.yellow('âš ')} Running ${chalk.bold(meta.command.name)} command in ${chalk.blue.bold(mode)} mode.\n`)
      }

      // Multivalue settings
      const options = new Set(['ignorecircular', 'volume', 'env', 'replace', 'alias', 'buildoption', 'autoimport', 'embed'])
      options.forEach(flag => {
        const { recognized } = meta.flags
        if (recognized.hasOwnProperty(flag)) {
          if (!Array.isArray(recognized[flag])) {
            meta.flags.recognized[flag] = Object.keys(recognized[flag]).map(key => `${key}=${recognized[flag][key]}`)
          }

          if (data.dev[flag]) {
            if (!Array.isArray(data.dev[flag])) {
              data.dev[flag] = Object.keys(data.dev[flag]).map(key => `${key}=${data.dev[flag][key]}`)
            }

            meta.flags.recognized[flag] = Array.from(new Set(recognized[flag].concat(data.dev[flag])))
          }

          if (data.dev[mode] && data.dev[mode][flag]) {
            if (!Array.isArray(data.dev[mode][flag])) {
              data.dev[mode][flag] = Object.keys(data.dev[mode][flag]).map(key => `${key}=${data.dev[mode][flag][key]}`)
            }

            meta.flags.recognized[flag] = Array.from(new Set(recognized[flag].concat(data.dev[mode][flag])))
          }
        }
      })

      // Single primitive value settings
      for (const [key, value] of Object.entries(data.dev)) {
        if (primitives.has(typeof value) && !options.has(key) && !commonflags[key] && meta.flags.recognized[key] !== undefined) {
          meta.flags.recognized[key] = value
        }
      }

      if (data.dev[mode]) {
        for (const [key, value] of Object.entries(data.dev[mode])) {
          if (primitives.has(typeof value) && !options.has(key) && meta.flags.recognized[key] !== undefined) {
            meta.flags.recognized[key] = value
          }
        }
      }

      next()
    })
  }
}

cli.exec(process.argv.slice(2)).catch(console.error)
