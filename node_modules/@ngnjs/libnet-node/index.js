// @ngnjs/libnet-node v1.0.0-alpha.1
// Copyright (c) 2022 Corey Butler

// Released under the MIT License.
import path from"path";import fs from"fs";import os from"os";import crypto from"crypto";function _classPrivateFieldGet(receiver,privateMap){return function _classApplyDescriptorGet(receiver,descriptor){return descriptor.get?descriptor.get.call(receiver):descriptor.value}(receiver,_classExtractFieldDescriptor(receiver,privateMap,"get"))}function _classPrivateFieldSet(receiver,privateMap,value){return function _classApplyDescriptorSet(receiver,descriptor,value){if(descriptor.set)descriptor.set.call(receiver,value);else{if(!descriptor.writable)throw new TypeError("attempted to set read only private field");descriptor.value=value}}(receiver,_classExtractFieldDescriptor(receiver,privateMap,"set"),value),value}function _classExtractFieldDescriptor(receiver,privateMap,action){if(!privateMap.has(receiver))throw new TypeError("attempted to "+action+" private field on non-instance");return privateMap.get(receiver)}function nullIf(sourceExpression,comparisonExpression=""){try{if(sourceExpression!==comparisonExpression){if(typeof sourceExpression!=typeof comparisonExpression)return sourceExpression;if("string"==typeof sourceExpression&&sourceExpression.trim()!==comparisonExpression.trim())return sourceExpression}return sourceExpression===comparisonExpression?null:sourceExpression}catch(e){throw new Error(`nullIf could not compare '${sourceExpression}' to '${comparisonExpression}'. ${e.message}`)}}function converge(){if(arguments.length<2)return null;if(2===arguments.length)return void 0===arguments[1]?null:!0===arguments[0]?nullIf(arguments[1]):arguments[1];for(let i=1;i<arguments.length;i++)if(void 0!==arguments[i]&&null!==(arguments[0]?nullIf(arguments[i]):arguments[i]))return arguments[i];return null}function coalesce(){return converge(!1,...arguments)}function coalesceb(){return converge(!0,...arguments)}const modes=new Set(["default","no-store","reload","no-cache","force-cache","only-if-cached"]),cacheable=new Set(["GET","HEAD","POST"]);var _storageEngine=new WeakMap,_dir=new WeakMap,_store=new WeakMap,_parse=new WeakMap,_write=new WeakMap;class Cache{constructor(storage="memory"){if(_storageEngine.set(this,{writable:!0,value:void 0}),_dir.set(this,{writable:!0,value:null}),_store.set(this,{writable:!0,value:new Map}),_parse.set(this,{writable:!0,value:content=>content}),_write.set(this,{writable:!0,value:(request,response)=>{const conn=this.connection(request);_classPrivateFieldGet(this,_store).has(conn.protocol)||_classPrivateFieldGet(this,_store).set(conn.protocol,new Map),_classPrivateFieldGet(this,_store).get(conn.protocol).has(conn.host)||_classPrivateFieldGet(this,_store).get(conn.protocol).set(conn.host,new Map),_classPrivateFieldGet(this,_store).get(conn.protocol).get(conn.host).has(conn.method)||_classPrivateFieldGet(this,_store).get(conn.protocol).get(conn.host).set(conn.method,new Map);const item={};Object.defineProperties(item,{request:{enumerable:!0,get:()=>{if("memory"===_classPrivateFieldGet(this,_storageEngine)){const conn=this.connection(request);return{method:conn.method,path:conn.path,host:conn.host,headers:request.headers,raw:request.RESPONSE_BUFFER}}try{return _classPrivateFieldGet(this,_parse).call(this,fs.readFileSync(path.resolve(_classPrivateFieldGet(this,_dir),conn.host,conn.method,conn.path+".cache")).toString().split(/\n-{3,}\n/)[0],"response")}catch(e){return null}}},response:{enumerable:!0,get:()=>{if("memory"===_classPrivateFieldGet(this,_storageEngine))return Object.assign(response,{raw:coalesce(request.RESPONSE_BUFFER,Buffer.from([])).toString()});if("disk"===_classPrivateFieldGet(this,_storageEngine))try{return _classPrivateFieldGet(this,_parse).call(this,fs.readFileSync(path.resolve(_classPrivateFieldGet(this,_dir),conn.host,conn.method,conn.path+".cache")).toString().split(/\n-{3,}\n/)[1],"response")}catch(e){return null}}}}),_classPrivateFieldGet(this,_store).get(conn.protocol).get(conn.host).get(conn.method).set(conn.path,item)}}),globalThis[Symbol.for("NGN.HttpCache")]instanceof Cache)return globalThis[Symbol.for("NGN.HttpCache")];if(_classPrivateFieldSet(this,_storageEngine,storage.trim().toLowerCase()),"memory"!==_classPrivateFieldGet(this,_storageEngine)&&(_classPrivateFieldSet(this,_dir,path.resolve(_classPrivateFieldGet(this,_storageEngine))),_classPrivateFieldSet(this,_storageEngine,"directory"),!fs.accessSync(_classPrivateFieldGet(this,_dir),fs.constants.W_OK)||!fs.statSync(_classPrivateFieldGet(this,_dir)).isDirectory()))throw new Error(`Cannot access the cache storage directory "${_classPrivateFieldGet(this,_dir)}". Make sure the path exists and is a writable directory.`);globalThis[Symbol.for("NGN.HttpCache")]=this}get size(){let ct=0;return _classPrivateFieldGet(this,_store).forEach(hosts=>hosts.forEach(res=>{ct+=res.size})),ct}get(request,cachemode=null){if(null!==cachemode){if(cachemode=cachemode.trim().toLowerCase(),!modes.has(cachemode))throw new Error(`"${cachemode}" is not a valid cachemode. Must be one of: ${Array.from(modes).join(", ")}.`);if(!cacheable.has(request.method.trim().toUpperCase()))return null;switch(cachemode){case"no-store":case"reload":return null}}const conn=this.connection(request),meta={age:0,status:"stale"},result={status:"stale"};if(this.has(request)){const item=_classPrivateFieldGet(this,_store).get(conn.protocol).get(conn.host).get(conn.method).get(conn.path);result.exists=!0,Object.defineProperty(result,"response",{enumerable:!0,get:()=>(item.age=meta.age,item.status=meta.status,item)});let freshnessLifetime=null;if(item.response.headers["cache-control"]&&(freshnessLifetime=coalesce(/^max-age\s+?=\s+?([0-9]+)/i.exec(item.response.headers["cache-control"]||""),[null,null])[1]),item.response.headers.date){if(null===freshnessLifetime&&item.response.headers.expires)try{freshnessLifetime=function forceNumber(value,radix=null){try{switch(function typeOf(el){if(void 0===el)return"undefined";if(null===el)return"null";const value=Object.prototype.toString.call(el).split(" ")[1].replace(/[^A-Za-z]/gi,"").toLowerCase();if("function"===value||"function"==typeof el){if(!el.name){const name=coalesceb(el.toString().replace(/\n/gi,"").replace(/^function\s|\(.*$/gim,"").toLowerCase(),"function");return name.indexOf(" ")>=0?"function":name.toLowerCase()}return coalesceb(el.name,"function").toLowerCase()}return value.toLowerCase()}(value)){case"boolean":return value?1:0;case"number":return value;case"date":return value.getTime();case"string":return null!==radix?parseInt(value,radix):parseFloat(value);default:return NaN}}catch(e){return NaN}}(item.response.headers.expires)-Date.parse(item.response.headers.date).getTime()}catch(e){}if(null===freshnessLifetime&&item.response.headers["last-modified"])try{freshnessLifetime=(Date.parse(item.response.headers.date).getTime()-Date.parse(item.response.headers["last-modified"]).getTime())/10}catch(e){}}const currentDateTime=(new Date).getTime();meta.age=(new Date).getTime()-coalesce(item.cacheDate,0),currentDateTime+coalesce(freshnessLifetime,0)-meta.age>0&&(result.status="fresh")}else Object.defineProperty(result,"response",{enumerable:!0,get:()=>null});return coalesce(result.response)}put(request,response,cachemode="default"){if(!modes.has(cachemode))throw new Error(`"${cachemode}" is an invalid caching mode. Must be one of: ${Array.from(modes).map(", ")}.`);if(!cacheable.has(request.method.toUpperCase())||void 0===request.RESPONSE_BUFFER)return response;if("no-store"===(response.headers["cache-control"]||"").toLowerCase())return response;switch(request.headers=coalesce(request.headers,{}),cachemode){case"reload":case"force-cache":_classPrivateFieldGet(this,_write).call(this,request,response);break;case"default":case"no-cache":304!==response.statusCode&&_classPrivateFieldGet(this,_write).call(this,request,response)}return response}connection(request){return{method:request.method.toUpperCase(),protocol:coalesce(request.protocol,request.agent.protocol).replace(/:/gi,""),host:/^(.*:[0-9]+):?/i.exec(Object.keys(request.agent.sockets)[0])[1],path:request.path}}match(request,cacheItem=null){let vary=coalesce(request.getHeader("vary"),"");if(""===vary.length)return!0;let item=cacheItem;if(!item){const conn=this.connection(request);try{item=_classPrivateFieldGet(this,_store).get(conn.host).get(conn.method).get(conn.path)}catch(e){return!1}}if(!item)return!1;if(0===vary.length)return!0;vary=vary.split(",");const headers=new Set(Array.from(item.headers.keys()).map(header=>header.trim().toLowerCase()));return 1===vary.length&&"*"===vary[0].trim()?0===vary.filter(header=>!headers.has(header.trim().toLowerCase())).length:0===vary.filter(header=>headers.delete(header.trim().toLowerCase())).length&&0===headers.size}has(request){if(0===this.size)return!1;const conn=this.connection(request);return!!(_classPrivateFieldGet(this,_store).has(conn.protocol)&&_classPrivateFieldGet(this,_store).get(conn.protocol).has(conn.host)&&_classPrivateFieldGet(this,_store).get(conn.protocol).get(conn.host).has(conn.method)&&_classPrivateFieldGet(this,_store).get(conn.protocol).get(conn.host).get(conn.method).has(conn.path))&&this.match(request,_classPrivateFieldGet(this,_store).get(conn.protocol).get(conn.host).get(conn.method).get(conn.path))}shouldCapture(request,cachemode="no-store"){if(cacheable.has(request.method.trim().toUpperCase())&&modes.has(cachemode))switch(cachemode){case"reload":return!0;case"force-cache":return!this.has(request);case"default":{if(!this.has(request))return!0;const item=this.get(request);if("stale"===item.status)return request.headers=request.headers||{},request.headers["If-None-Match"]=coalesce(item.response.headers.etag,"*"),!0;break}case"no-cache":if(this.has(request)){const item=this.get(request);request.headers=request.headers||{},request.headers["If-None-Match"]=coalesce(item.response.headers.etag,"*")}return!0}return!1}capture(request,cachemode="no-store"){this.shouldCapture(request,cachemode)&&request.once("socket",socket=>{socket.setNoDelay(!0),socket.on("data",chunk=>{request.RESPONSE_BUFFER=request.RESPONSE_BUFFER?Buffer.concat([request.RESPONSE_BUFFER,chunk],request.RESPONSE_BUFFER.length+chunk.length):chunk})})}flush(uri){const url=new URL(uri),host=url.host;_classPrivateFieldGet(this,_store).forEach(store=>{store.has(host)&&store.get(host).forEach(method=>{store.get(host).get(method).delete(url.path),"disk"===_classPrivateFieldGet(this,_storageEngine)&&fs.unlinkSync(path.join(_classPrivateFieldGet(this,_dir),host,method,url.pathname+".cache")),0===store.get(host).get(method).size&&(store.get(host).delete(method),"disk"===_classPrivateFieldGet(this,_storageEngine)&&fs.rmdirSync(path.join(_classPrivateFieldGet(this,_dir),host,method),{recursive:!0})),0===store.get(host).size&&(store.delete(host),"disk"===_classPrivateFieldGet(this,_storageEngine)&&fs.rmdirSync(path.join(_classPrivateFieldGet(this,_dir),host),{recursive:!0}))})})}clear(){new Set([...arguments]).forEach(this.flush)}empty(){"disk"===_classPrivateFieldGet(this,_storageEngine)&&fs.rmdirSync(_classPrivateFieldGet(this,_dir),{maxRetries:2,recursive:!0}),_classPrivateFieldSet(this,_store,new Map)}get data(){const data={};for(const[protocol,domain]of _classPrivateFieldGet(this,_store).entries())data[protocol]=convert(domain);return data}}function convert(map){const data={};if(!(map instanceof Map)&&"object"==typeof map){console.log(map.request.raw.toString());for(const[key,value]of Object.entries(map))data[key]="request"===key||"response"===key?value.raw.toString():value;return data}for(const[key,value]of map.entries())data[key]=convert(value);return data}const REFERRER_MODES=new Set(["no-referrer","no-referrer-when-downgrade","same-origin","origin","strict-origin","origin-when-cross-origin","strict-origin-when-cross-origin","unsafe-url"]),HOSTNAME=os.hostname().toLocaleLowerCase(),interfaces=new Set(["127.0.0.1","localhost",HOSTNAME]);for(const value of Object.values(os.networkInterfaces()))for(const item of value)interfaces.add("IPv4"===item.family?item.address:`[${item.address}]`);const INTERFACES$1=Array.from(interfaces),policies=REFERRER_MODES,INTERFACES=new Set(INTERFACES$1);var _policy=new WeakMap;class ReferrerPolicy{constructor(policy=""){_policy.set(this,{writable:!0,value:"no-referrer-when-downgrade"}),policy=policy.trim().toLowerCase(),this.policy=policy}get policy(){return _classPrivateFieldGet(this,_policy)}set policy(policy){if((policy=policy||"no-referrer-when-downgrade")!==_classPrivateFieldGet(this,_policy)){if(!policies.has(policy))throw new Error(`"${policy}" is not a valid policy. Must be one of: ${Array.from(policies).join(", ")}`);_classPrivateFieldSet(this,_policy,policy)}}stripReferrer(url=null,originonly=!0){return null===url?null:(url instanceof URL||(/^\w+:/i.test(url)||(url="http://"+url),url=new URL(url)),INTERFACES.has(url.hostname.toLowerCase())?null:`${url.protocol}//${url.host}`+(originonly?"":`${url.pathname}${url.search}`))}referrerURL(from,to){if("no-referrer"===_classPrivateFieldGet(this,_policy)||!from||!to)return null;if(from="string"==typeof from?new URL(from):from,to="string"==typeof to?new URL(to):to,"file:"===from.protocol||"data:"===from.protocol)return null;const sameOrigin=from.host===to.host;switch(_classPrivateFieldGet(this,_policy)){case"unsafe-url":return this.stripReferrer(from,!1);case"no-referrer-when-downgrade":return"https:"===from.protocol&&"https:"!==to.protocol?null:this.stripReferrer(from,!1);case"same-origin":return sameOrigin?this.stripReferrer(from,!1):null;case"origin":return`${from.protocol}//${from.host}/`;case"strict-origin":return"https:"!==to.protocol&&sameOrigin?null:from.protocol===to.protocol||sameOrigin?this.stripReferrer(from)+"/":null;case"origin-when-cross-origin":return sameOrigin&&from.protocol===to.protocol?this.stripReferrer(from,!1):this.stripReferrer(from)+"/";case"strict-origin-when-cross-origin":return sameOrigin?this.stripReferrer(from,!1):from.protocol===to.protocol?this.stripReferrer(from)+"/":null}return null}}const algorithms=new Set(["sha256","sha384","sha512"]);class SRI{static verify(integrityHash,content,encoding="utf8"){const integrity=/^(?<algorithm>sha[0-9]{3})-(?<hash>.*)/i.exec(integrityHash);if(!integrity)return{valid:!1,reason:`"${integrityHash}" is invalid (improper format, expected {sha###}-{hash} format).`};const{algorithm:algorithm,hash:hash}=integrity.groups;try{if(SRI.checksum(algorithm,content,encoding)!==hash)return{valid:!1,reason:"Integrity mismatch."}}catch(e){return{valid:!1,reason:e.message}}return{valid:!0,reason:"Integrity match."}}static checksum(algorithm,content,encoding="utf8"){if(algorithm=algorithm.toLowerCase(),!algorithms.has(algorithm))throw new Error(`Invalid algorithm (${algorithm}). Expected one of: ${Array.from(algorithms).join(", ")}`);return crypto.createHash(algorithm).update(content,encoding).digest("base64")}static generate(content,algorithm="sha512",encoding="utf8"){if(algorithm=algorithm.trim().toLowerCase(),!algorithms.has(algorithm))throw new Error(`Invalid algorithm: ${algorithm}. Must be one of: ${Array.from(algorithms).join(", ")}`);return`${algorithm}-${SRI.checksum(algorithm,content,encoding)}`}}const moduleVersion="1.0.0-alpha.1";export{Cache,HOSTNAME,INTERFACES$1 as INTERFACES,ReferrerPolicy,SRI,moduleVersion};
//# sourceMappingURL=../libnet-node-debug/index.js.map
