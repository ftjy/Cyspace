// @ngnjs/libcrypto v1.0.0
// Copyright (c) 2022 Corey Butler
// Released under the MIT License.
const runtime=void 0!==globalThis.process?"node":globalThis.hasOwnProperty("Deno")?"deno":"browser";let nodecrypto,cryptography=null;"node"===runtime?(async()=>{nodecrypto=await import("crypto");try{cryptography=nodecrypto.webcrypto}catch(e){}})():cryptography=globalThis.crypto;const arrayBufferToString=buffer=>String.fromCharCode.apply(null,new Uint8Array(buffer));function stringToArrayBuffer(str){const buf=new ArrayBuffer(str.length),bufView=new Uint8Array(buf);for(let i=0,strLen=str.length;i<strLen;i++)bufView[i]=str.charCodeAt(i);return buf}const BTOA=globalThis.btoa||function(v){return Buffer.from(v,"binary").toString("base64")},ATOB=globalThis.atob||function(v){return Buffer.from(v,"base64").toString("hex")},bufToBase64=buff=>BTOA(arrayBufferToString(buff)),base64ToBuf=str=>Uint8Array.from(ATOB(str),c=>c.charCodeAt(0)),URL_stringify=a=>bufToBase64(a).replace(/=+/g,"").replace(/\+/g,"-").replace(/\//g,"_"),PEM_KEY_PATTERN=/-{5}(BEGIN\s.+\s?KEY)-{5}.+-{5}(END\s.+\s?KEY)-{5}/i,PEM_PUBLIC_KEY_PATTERN=/-{5}(BEGIN\s((RSA|EC)\s)?PUBLIC\sKEY)-{5}/i,PEM_PRIVATE_KEY_PATTERN=/-{5}(BEGIN\s((RSA|EC)\s)?PRIVATE\sKEY)-{5}/i,isPrivateKey=pem=>PEM_PRIVATE_KEY_PATTERN.test(pem),typeOf=pem=>/-{5}(BEGIN (ENCRYPTED\s)?RSA.+)-{5}/.test(pem)?"RSA":/-{5}(BEGIN (ENCRYPTED\s)?EC.+)-{5}/.test(pem)?"EC":/-{5}(BEGIN.+KEY)-{5}/.test(pem)?pem.length>425?"RSA":"EC":null,encode=(label,data,type="")=>{const base64encodedWrapped=BTOA(data).replace(/(.{64})/g,"$1\n");return`-----BEGIN ${label=(type.length>0?type.trim().toUpperCase()+" ":"")+label}-----\n${base64encodedWrapped}\n-----END ${label}-----`},decode=key=>{const pem=key.replace(/(-{5}([A-Za-z\s]+)KEY-{5})/gi,"").trim();return stringToArrayBuffer(ATOB(pem))};async function exportKeyAsString(format,key){return arrayBufferToString(await cryptography.subtle.exportKey(format,key))}async function importStringAsKey(pem,algorithm){const privateKey=isPrivateKey(pem),encoding=privateKey?"pkcs8":"spki",usage=[];return"RSA-OAEP"===algorithm.name?usage.push(privateKey?"decrypt":"encrypt"):usage.push(privateKey?"sign":"verify"),await cryptography.subtle.importKey(encoding,decode(pem),algorithm,!0,usage)}function getDefaultAlgorithm(pem,algorithm,pemtype){return algorithm||("RSA"===(pemtype=pemtype||typeOf(pem))?"RSASSA-PKCS1-v1_5":"P-256")}const PEM={isPrivateKey:isPrivateKey,isPublicKey:pem=>PEM_PUBLIC_KEY_PATTERN.test(pem),isKey:pem=>PEM_KEY_PATTERN.test(pem),typeOf:typeOf,extractKey:async(pem,algorithm)=>{const pemtype=typeOf(pem);return"RSA"===pemtype?await async function importStringAsRSAKey(pem,algorithm="RSASSA-PKCS1-v1_5",hash="SHA-256"){return importStringAsKey(pem,algorithm="object"==typeof algorithm?algorithm:{name:algorithm,hash:hash})}(pem,getDefaultAlgorithm(pem,algorithm,pemtype).name):await(async(pem,namedCurve="P-256")=>importStringAsKey(pem,{name:"ECDSA",namedCurve:namedCurve}))(pem)},encodePrivateKey:async(key,type="")=>encode("PRIVATE KEY",await exportKeyAsString("pkcs8",key),type),encodePublicKey:async(key,type="")=>encode("PUBLIC KEY",await exportKeyAsString("spki",key),type),encode:encode,decode:decode,getDefaultAlgorithm:getDefaultAlgorithm},lookup=[],revLookup=[],placeHolderPadLookup=[0,1,,2,3,,4],code="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";function encodeBase32Chunk(uint8,start,end){let tmp;const output=[];for(let i=start;i<end;i+=5)tmp=uint8[i]<<16&16711680|uint8[i+1]<<8&65280|255&uint8[i+2],output.push(lookup[tmp>>19&31],lookup[tmp>>14&31],lookup[tmp>>9&31],lookup[tmp>>4&31]),tmp=(15&tmp)<<16|uint8[i+3]<<8&65280|255&uint8[i+4],output.push(lookup[tmp>>15&31],lookup[tmp>>10&31],lookup[tmp>>5&31],lookup[31&tmp]);return output.join("")}function truncate(hs){const offset=15&hs[19];return(127&hs[offset])<<24|hs[offset+1]<<16|hs[offset+2]<<8|hs[offset+3]}function zeropad(value,digits=16){return("0".repeat(digits)+value).slice(-digits)}code.split("").forEach((v,i)=>{lookup[i]=v,revLookup[code.charCodeAt(i)]=i});const base32={encode:str=>function bufToBase32(uint8){let tmp;const extraBytes=uint8.byteLength%5,parts=[],len=uint8.byteLength-extraBytes;for(let i=0;i<len;i+=16385)parts.push(encodeBase32Chunk(uint8,i,i+16385>len?len:i+16385));return 4===extraBytes?(tmp=(255&uint8[len])<<16|(255&uint8[len+1])<<8|255&uint8[len+2],parts.push(lookup[tmp>>19&31],lookup[tmp>>14&31],lookup[tmp>>9&31],lookup[tmp>>4&31]),tmp=(15&tmp)<<11|uint8[len+3]<<3,parts.push(lookup[tmp>>10&31],lookup[tmp>>5&31],lookup[31&tmp],"=")):3===extraBytes?(tmp=(255&uint8[len])<<17|(255&uint8[len+1])<<9|(255&uint8[len+2])<<1,parts.push(lookup[tmp>>20&31],lookup[tmp>>15&31],lookup[tmp>>10&31],lookup[tmp>>5&31],lookup[31&tmp],"===")):2===extraBytes?(tmp=(255&uint8[len])<<12|(255&uint8[len+1])<<4,parts.push(lookup[tmp>>15&31],lookup[tmp>>10&31],lookup[tmp>>5&31],lookup[31&tmp],"====")):1===extraBytes&&(tmp=(255&uint8[len])<<2,parts.push(lookup[tmp>>5&31],lookup[31&tmp],"======")),parts.join("")}(Uint8Array.from(Array.from(str).map(l=>l.charCodeAt(0)))),decode:input=>arrayBufferToString(function base32ToBuf(b32){let tmp,curByte=0;const[validLen,placeHoldersLen]=function getLens(b32){const len=b32.length;if(len%8>0)throw new Error("Invalid string. Length must be a multiple of 8");let validLen=b32.indexOf("=");return-1===validLen&&(validLen=len),[validLen,validLen===len?0:8-validLen%8]}(b32),arr=new Uint8Array(function _byteLength(validLen,placeHoldersLen){return 5*(validLen+placeHoldersLen)/8-function _getPadLen(placeHoldersLen){const maybeLen=placeHolderPadLookup[placeHoldersLen];if("number"!=typeof maybeLen)throw new Error("Invalid pad length");return maybeLen}(placeHoldersLen)}(validLen,placeHoldersLen)),len=placeHoldersLen>0?validLen-8:validLen;let i;for(i=0;i<len;i+=8)tmp=revLookup[b32.charCodeAt(i)]<<20|revLookup[b32.charCodeAt(i+1)]<<15|revLookup[b32.charCodeAt(i+2)]<<10|revLookup[b32.charCodeAt(i+3)]<<5|revLookup[b32.charCodeAt(i+4)],arr[curByte++]=tmp>>17&255,arr[curByte++]=tmp>>9&255,arr[curByte++]=tmp>>1&255,tmp=(1&tmp)<<15|revLookup[b32.charCodeAt(i+5)]<<10|revLookup[b32.charCodeAt(i+6)]<<5|revLookup[b32.charCodeAt(i+7)],arr[curByte++]=tmp>>8&255,arr[curByte++]=255&tmp;return 1===placeHoldersLen?(tmp=revLookup[b32.charCodeAt(i)]<<20|revLookup[b32.charCodeAt(i+1)]<<15|revLookup[b32.charCodeAt(i+2)]<<10|revLookup[b32.charCodeAt(i+3)]<<5|revLookup[b32.charCodeAt(i+4)],arr[curByte++]=tmp>>17&255,arr[curByte++]=tmp>>9&255,arr[curByte++]=tmp>>1&255,tmp=(1&tmp)<<7|revLookup[b32.charCodeAt(i+5)]<<2|revLookup[b32.charCodeAt(i+6)]>>3,arr[curByte++]=255&tmp):3===placeHoldersLen?(tmp=revLookup[b32.charCodeAt(i)]<<19|revLookup[b32.charCodeAt(i+1)]<<14|revLookup[b32.charCodeAt(i+2)]<<9|revLookup[b32.charCodeAt(i+3)]<<4|revLookup[b32.charCodeAt(i+4)]>>1,arr[curByte++]=tmp>>16&255,arr[curByte++]=tmp>>8&255,arr[curByte++]=255&tmp):4===placeHoldersLen?(tmp=revLookup[b32.charCodeAt(i)]<<11|revLookup[b32.charCodeAt(i+1)]<<6|revLookup[b32.charCodeAt(i+2)]<<1|revLookup[b32.charCodeAt(i+3)]>>4,arr[curByte++]=tmp>>8&255,arr[curByte++]=255&tmp):6===placeHoldersLen&&(tmp=revLookup[b32.charCodeAt(i)]<<3|revLookup[b32.charCodeAt(i+1)]>>2,arr[curByte++]=255&tmp),arr}(input))};async function HOTP(secret,cfg={}){const algorithm=cfg.algorithm||"SHA-1",algo=algorithm.trim().replace("-","").toLowerCase(),counter=cfg.counter||0,digits=cfg.digits||6;if("node"===runtime&&!cryptography){const hmac=function createNodeHMAC(secret,data,algorithm){const buffer=Buffer.alloc(8);if(Number.isFinite(data)||"bigint"==typeof data)buffer.write(zeropad(data.toString(16)),0,"hex");else if(Buffer.isBuffer(data))data.copy(buffer);else{if("string"!=typeof data)throw new Error("Unexpected data type "+typeof data);buffer.write(zeropad(data),0,"hex")}return nodecrypto.createHmac(algorithm,secret).update(buffer).digest()}(secret,counter,algo);return zeropad(truncate(hmac),digits)}secret=stringToArrayBuffer(secret);const key=await cryptography.subtle.importKey("raw",secret,{name:"HMAC",hash:{name:algorithm}},!1,["sign"]);return truncate(new Uint8Array(await cryptography.subtle.sign("HMAC",key,function pad(counter){const array=counter.toString(16).padStart(16,"0").match(/..?/g).map(v=>parseInt(v,16));return Uint8Array.from(array)}(counter)))).toString().padStart(digits,"0").slice(0-digits)}async function TOTP(secret,cfg={}){return cfg.counter=cfg.timestamp||Math.floor(+new Date/(1e3*(cfg.seconds||30))),cfg.digits=cfg.digits||6,HOTP(secret,cfg)}const SHA256={name:"SHA-256"},SHA384={name:"SHA-384"},SHA512={name:"SHA-512"},ALGORITHMS={HS256:{name:"HMAC",hash:SHA256},HS384:{name:"HMAC",hash:SHA384},HS512:{name:"HMAC",hash:SHA512},RS256:{name:"RSASSA-PKCS1-v1_5",hash:SHA256},RS384:{name:"RSASSA-PKCS1-v1_5",hash:SHA384},RS512:{name:"RSASSA-PKCS1-v1_5",hash:SHA512},EC256:{name:"ECDSA",namedCurve:"P-256",hash:SHA256},EC384:{name:"ECDSA",namedCurve:"P-384",hash:SHA384},EC512:{name:"ECDSA",namedCurve:"P-512",hash:SHA512}},utf8ToUint8Array=str=>{return s=BTOA(unescape(encodeURIComponent(str))),base64ToBuf(s.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,""));var s};async function hmac(secret,alg="HS256",data){return await cryptography.subtle.importKey("raw",utf8ToUint8Array(secret),ALGORITHMS[alg],!1,["sign","verify"])}async function sign$1(key,data,alg="HS256"){return await cryptography.subtle.sign({name:ALGORITHMS[alg].name},key,utf8ToUint8Array(data))}function NANOID(size=21){"string"==typeof size&&(size=isNaN(size)?21:parseInt(size,10));const bytes="node"===runtime?nodecrypto.randomBytes(size):cryptography.getRandomValues(new Uint8Array(size));let id="";for(;size--;){const n=63&bytes[size];id+=n<36?n.toString(36):n<62?(n-26).toString(36).toUpperCase():n<63?"_":"-"}return id}const all={createToken:async function createToken({account:account,secret:secret,claims:claims={},algorithm:algorithm="HS256",expiration:expiration,issuer:issuer,headers:headers=null}){const header=Object.assign({typ:"JWT",alg:ALGORITHMS[algorithm].name},headers),claim=Object.assign(claims,{iat:(new Date).getTime(),exp:expiration||(new Date).getTime()+36e5,jti:NANOID(28)});account&&(claim.sub=account),issuer&&(claim.iss=issuer);const payload=`${URL_stringify(utf8ToUint8Array(JSON.stringify(header)))}.${URL_stringify(utf8ToUint8Array(JSON.stringify(claim)))}`;if("node"===runtime&&!cryptography)return`${payload}.${nodecrypto.createHmac(ALGORITHMS[algorithm].hash.name.replace("-",""),secret).update(payload).digest("base64").replace(/=+/g,"").replace(/\+/g,"-").replace(/\//g,"_")}`;const key=await hmac(secret,algorithm),signature=await sign$1(key,payload,algorithm);return`${payload}.${URL_stringify(new Uint8Array(signature))}`},verifyToken:async function verifyToken(token,secret,alg="HS256"){const payload=token.split(".").slice(0,2).join(".");if("node"===runtime&&!cryptography)return nodecrypto.createHmac(ALGORITHMS[alg].hash.name.replace("-",""),secret).update(payload).digest("base64").replace(/=+/g,"").replace(/\+/g,"-").replace(/\//g,"_")===token.split(".").pop();const key=await hmac(secret,alg),signature=await sign$1(key,payload,alg);return await cryptography.subtle.verify({name:ALGORITHMS[alg].name},key,signature,utf8ToUint8Array(payload))}},encoder=new TextEncoder,decoder=new TextDecoder,IV_LENGTH="deno"===runtime?16:12,ENCRYPTION_ALGORITHM="deno"===runtime?"AES-CBC":"AES-GCM";async function generateRSAKeyPair(bit=2048,hash="SHA-256"){return"node"!==runtime||cryptography?await generateKeyPair({name:"RSASSA-PKCS1-v1_5",modulusLength:bit,publicExponent:new Uint8Array([1,0,1]),hash:hash},"RSA"):new Promise((resolve,reject)=>{nodecrypto.generateKeyPair("rsa",{modulusLength:bit,publicExponent:65793,publicKeyEncoding:{type:"spki",format:"pem"},privateKeyEncoding:{type:"pkcs8",format:"pem"}},(err,publicKey,privateKey)=>{err?reject(err):resolve({publicKey:publicKey,privateKey:privateKey})})})}async function generateKeys(){return await generateRSAKeyPair(...arguments)}async function generateECDSAKeyPair(namedCurve="P-256"){return"node"!==runtime||cryptography?await generateKeyPair({name:"ECDSA",namedCurve:namedCurve},"EC"):new Promise((resolve,reject)=>{nodecrypto.generateKeyPair("ec",{namedCurve:namedCurve,publicKeyEncoding:{type:"spki",format:"pem"},privateKeyEncoding:{type:"pkcs8",format:"pem"}},(err,publicKey,privateKey)=>{err?reject(err):resolve({publicKey:publicKey,privateKey:privateKey})})})}async function generateECKeyPair(){return await generateECDSAKeyPair(...arguments)}async function sign(data,pem,algorithm){if("object"==typeof data&&(data=JSON.stringify(data)),"node"===runtime&&!cryptography){const signer=nodecrypto.createSign("SHA256");return signer.update(data),signer.end(),signer.sign(pem).toString("base64")}"ECDSA"===(algorithm={name:PEM.getDefaultAlgorithm(pem,algorithm)}).name&&(algorithm.hash="SHA-256");const key=await PEM.extractKey(pem,algorithm),buffer=await cryptography.subtle.sign(algorithm,key,encoder.encode(data));return bufToBase64(buffer)}async function verify(data,signature,pem,algorithm="RSASSA-PKCS1-v1_5"){if("object"==typeof data&&(data=JSON.stringify(data)),"node"===runtime&&!cryptography){const verifier=nodecrypto.createVerify("SHA256");return verifier.update(data),verifier.end(),verifier.verify(pem,signature,"base64")}"ECDSA"===(algorithm={name:PEM.getDefaultAlgorithm(pem,algorithm)}).name&&(algorithm.hash="SHA-256");const key=await PEM.extractKey(pem,algorithm);return await cryptography.subtle.verify(algorithm,key,base64ToBuf(signature),encoder.encode(data))}async function encrypt(plaintext,secret){if(PEM.isPrivateKey(secret))throw new Error("Encryption requires a public key (a private key was specified)");if("object"==typeof plaintext&&(plaintext=JSON.stringify(plaintext)),"node"===runtime&&!cryptography){if(PEM.isPublicKey(secret)){const buffer=Buffer.from(plaintext,"utf8");return nodecrypto.publicEncrypt({key:secret,padding:nodecrypto.constants.RSA_PKCS1_OAEP_PADDING,oaepHash:"sha256"},buffer).toString("base64")}const iv=nodecrypto.randomBytes(IV_LENGTH),salt=nodecrypto.randomBytes(16),cipher=nodecrypto.createCipheriv("aes-256-gcm",simpleKey(secret),iv,{authTagLength:16}),encrypted=Buffer.concat([cipher.update(plaintext,"utf8"),cipher.final()]),tag=cipher.getAuthTag();return Buffer.concat([salt,iv,tag,encrypted]).toString("base64")}if(PEM.isPublicKey(secret)){const pemKey=await PEM.extractKey(secret,{name:"RSA-OAEP",hash:"SHA-256"}),ciphertext=await cryptography.subtle.encrypt({name:"RSA-OAEP"},pemKey,encoder.encode(plaintext));return bufToBase64(ciphertext)}const iv=cryptography.getRandomValues(new Uint8Array(IV_LENGTH)),data=encoder.encode(plaintext),{key:key,salt:salt}=await Key(secret);return function createBase64Cipher(salt,iv,cipher,tag){const encryptedContent=new Uint8Array(cipher),tagLength=tag?tag.byteLength:0,buf=new Uint8Array(salt.byteLength+iv.byteLength+encryptedContent.byteLength+tagLength);return buf.set(salt,0),buf.set(iv,salt.byteLength),tagLength>0&&buf.set(tag,salt.byteLength+iv.byteLength),buf.set(encryptedContent,salt.byteLength+iv.byteLength+tagLength),bufToBase64(buf.buffer)}(salt,iv,await cryptography.subtle.encrypt({name:ENCRYPTION_ALGORITHM,iv:iv},key,data))}async function decrypt(cipher,secret,autoparse=!0){if(PEM.isPublicKey(secret))throw new Error("Decryption requires a private key (a public key was specified)");const useNode="node"===runtime&&!cryptography,isPrivateKey=PEM.isPrivateKey(secret),encrypted=useNode&&!isPrivateKey?Buffer.from(cipher,"base64"):base64ToBuf(cipher),salt=encrypted.slice(0,16),iv=encrypted.slice(salt.byteLength,salt.byteLength+IV_LENGTH),tag=useNode&&!isPrivateKey?encrypted.slice(salt.byteLength+iv.byteLength,salt.byteLength+iv.byteLength+16):null,data=encrypted.slice(salt.byteLength+iv.byteLength+(tag?tag.byteLength:0));if(useNode){if(isPrivateKey){const buffer=Buffer.from(cipher,"base64");return parse(nodecrypto.privateDecrypt({key:secret,padding:nodecrypto.constants.RSA_PKCS1_OAEP_PADDING,oaepHash:"sha256"},buffer).toString("utf8"),autoparse)}const decipher=nodecrypto.createDecipheriv("aes-256-gcm",simpleKey(secret),iv,{authTagLength:16});return decipher.setAuthTag(tag),parse(decipher.update(data,"base64","utf-8")+decipher.final("utf-8"),autoparse)}if(PEM.isPrivateKey(secret)){const pemKey=await PEM.extractKey(secret,{name:"RSA-OAEP"}),buffer=await cryptography.subtle.decrypt({name:"RSA-OAEP"},pemKey,base64ToBuf(cipher)),data=new Uint8Array(buffer);return parse(decoder.decode(data),autoparse)}const{key:key}=await Key(secret,salt),decrypted=await cryptography.subtle.decrypt({name:ENCRYPTION_ALGORITHM,iv:iv},key,data).catch(e=>console.log("e: "+e.message));return parse(decoder.decode(decrypted),autoparse)}function parse(content,autoparse=!0){if(!autoparse)return content;try{return JSON.parse(content)}catch(e){return content}}const encryptionAlgorithm=secret=>PEM.isKey(secret)?"rsa256oaep":ENCRYPTION_ALGORITHM.toLowerCase().replace("-","256"),simpleKey=secret=>nodecrypto.createHash("md5").update(secret,"utf8").digest("hex");async function generateKeyPair(algorithm,type=""){const keypair=await cryptography.subtle.generateKey(algorithm,!0,["sign","verify"]);return{privateKey:await PEM.encodePrivateKey(keypair.privateKey,type),publicKey:await PEM.encodePublicKey(keypair.publicKey,type)}}async function Key(passphrase,salt,hash="SHA-256"){salt=salt||cryptography.getRandomValues(new Uint8Array(16));const secret=await cryptography.subtle.importKey("raw",encoder.encode(passphrase),"PBKDF2",!1,["deriveKey","deriveBits"]);return{key:await cryptography.subtle.deriveKey({name:"PBKDF2",salt:salt,iterations:1e4,hash:hash},secret,{name:ENCRYPTION_ALGORITHM,length:parseInt(hash.split("-").pop(),10)},!1,["encrypt","decrypt"]),salt:salt}}const crypto={encrypt:encrypt,decrypt:decrypt,encryptionAlgorithm:encryptionAlgorithm,generateKeys:generateKeys,generateRSAKeyPair:generateRSAKeyPair,generateECDSAKeyPair:generateECDSAKeyPair,generateECKeyPair:generateECKeyPair,PEM:PEM,sign:sign,verify:verify,HOTP:HOTP,TOTP:TOTP,base32:base32,JWT:all};export default crypto;export{HOTP,all as JWT,PEM,TOTP,base32,decrypt,encrypt,encryptionAlgorithm,generateECDSAKeyPair,generateECKeyPair,generateKeys,generateRSAKeyPair,sign,verify};
//# sourceMappingURL=../libcrypto-debug/index.js.map
